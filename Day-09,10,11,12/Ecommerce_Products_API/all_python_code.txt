# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\crud.py ---
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func, desc, asc
from sqlalchemy.orm import joinedload
from typing import Tuple, Dict, Any, Optional, List
import models, schemas
from logger import log

def create_product_manual(db: Session, product: schemas.ProductCreate):
    try:
        db_product = models.Product(**product.model_dump())
        db.add(db_product)
        db.commit()
        db.refresh(db_product)
        log.info(f"Product created manually: ID={db_product.id}, Name={db_product.name}")
        return db_product
    except Exception as e:
        db.rollback()
        log.error(f"Failed to create product: {e}")
        raise

def get_all_products(db: Session):
    products = db.query(models.Product).all()
    log.info(f"Retrieved {len(products)} products")
    return products

def get_product_by_id(db: Session, id: int):
    product = db.query(models.Product).filter(models.Product.id == id).first()
    if product:
        log.info(f"Found product by ID={id}: {product.name}")
    else:
        log.warning(f"No product found with ID={id}")
    return product

def get_product_by_name(db: Session, name: str):
    return db.query(models.Product).filter(models.Product.name == name).first()

def get_product_by_brand(db: Session, brand: str):
    return db.query(models.Product).filter(models.Product.brand == brand).first()

def get_products_by_category(db: Session, category_id: int):
    products = db.query(models.Product).filter(models.Product.category_id == category_id).all()
    log.info(f"Found {len(products)} products for Category ID={category_id}")
    return products

def get_all_categories(db: Session):
    categories = db.query(models.Category).all()
    log.info(f"Retrieved {len(categories)} categories")
    return categories

def get_paginated_products(
    db: Session, 
    skip: int, 
    limit: int, 
    search: Optional[str] = None,
    sort_by: str = "created_at",
    sort_dir: str = "desc",
    filters: Optional[Dict[str, Any]] = None
) -> Tuple[int, List[models.Product]]:
    try:
        log.info(f"Fetching paginated products | Skip={skip}, Limit={limit}, Search={search}, Sort={sort_by} {sort_dir}, Filters={filters}")
        query = db.query(models.Product).options(joinedload(models.Product.category))
        
        if search:
            search_term = f"%{search}%"
            query = query.filter(
                or_(
                    models.Product.name.like(search_term),
                    models.Product.brand.like(search_term)
                )
            )
        
        if filters:
            if filters.get('min_price'):
                query = query.filter(models.Product.price >= filters['min_price'])
            if filters.get('max_price'):
                query = query.filter(models.Product.price <= filters['max_price'])
            if filters.get('category_id'):
                query = query.filter(models.Product.category_id == filters['category_id'])
            if filters.get('in_stock_only'):
                query = query.filter(models.Product.stock_quantity > 0)

        total = query.count()

        if hasattr(models.Product, sort_by):
            sort_column = getattr(models.Product, sort_by)
            if sort_dir == "desc":
                query = query.order_by(desc(sort_column))
            else:
                query = query.order_by(asc(sort_column))
        else:
            log.warning(f"Invalid sort_by column '{sort_by}'")

        products = query.offset(skip).limit(limit).all()
        log.info(f"Returning {len(products)} products out of total {total}")
        return total, products
    
    except Exception as e:
        log.error(f"Error in get_paginated_products: {e}")
        raise

def update_product(db: Session, product_id: int, product_update: schemas.ProductUpdate):
    """Update a product with only the provided fields"""
    
    # Get the existing product - try by ID first, then by name, then by brand
    db_product = db.query(models.Product).filter(models.Product.id == product_id).first()
    
    if not db_product:
        # Try by name
        db_product = db.query(models.Product).filter(models.Product.name == str(product_id)).first()
    
    if not db_product:
        # Try by brand
        db_product = db.query(models.Product).filter(models.Product.brand == str(product_id)).first()
    
    if not db_product:
        return None
    
    # Get only the fields that were actually provided (not None)
    update_data = product_update.model_dump(exclude_unset=True)
    
    # Handle attributes separately for merging
    if 'attributes' in update_data:
        new_attributes = update_data.pop('attributes')
        
        if new_attributes is not None:
            # Initialize existing attributes as empty dict if None
            existing_attributes = db_product.attributes or {}
            
            if isinstance(new_attributes, dict) and new_attributes:
                # Merge with existing attributes instead of replacing
                merged_attributes = dict(existing_attributes)
                merged_attributes.update(new_attributes)
                db_product.attributes = merged_attributes
            elif new_attributes == {}:
                # If explicitly setting to empty dict, replace entirely
                db_product.attributes = {}
            # If new_attributes is empty dict or falsy, keep existing
        # If new_attributes is None, keep existing attributes unchanged
    
    # Update other fields
    for field, value in update_data.items():
        if hasattr(db_product, field):
            setattr(db_product, field, value)
    
    try:
        # Save changes
        db.commit()
        db.refresh(db_product)
        return db_product
    except Exception as e:
        # Rollback in case of any database errors
        db.rollback()
        raise e
    
def get_inventory_by_product_id(db: Session, product_id: int):
    return db.query(models.Inventory).filter(models.Inventory.product_id == product_id).first()

def update_inventory_quantity(db: Session, product_id: int, quantity_delta: int, reason: str = None, order_id: int = None):
    inventory = get_inventory_by_product_id(db, product_id)
    if not inventory:
        raise Exception("Inventory record not found for product_id")

    inventory.quantity_available += quantity_delta
    inventory.quantity_available = max(0, inventory.quantity_available)

    movement = models.StockMovement(
        product_id=product_id,
        order_id=order_id,
        change=quantity_delta,
        reason=reason
        )
    db.add(movement)
    db.commit()
    db.refresh(inventory)
    return inventory

def create_or_update_inventory(db: Session, product_id: int, data: schemas.InventoryBase):
    inventory = get_inventory_by_product_id(db, product_id)
    if not inventory:
        inventory = models.Inventory(product_id=product_id, **data.model_dump())
        db.add(inventory)
    else:
        for key, value in data.model_dump().items():
            setattr(inventory, key, value)
    db.commit()
    db.refresh(inventory)
    return inventory

def get_stock_movements_for_product(db: Session, product_id: int):
    return db.query(models.StockMovement).filter(models.StockMovement.product_id == product_id).order_by(models.StockMovement.timestamp.desc()).all()


def update_inventory_settings(
    db: Session,
    product_id: int,
    update_data: schemas.InventoryUpdate
):
    inventory = db.query(models.Inventory).filter(models.Inventory.product_id == product_id).first()
    if not inventory:
        raise Exception("Inventory not found")

    for key, value in update_data.model_dump(exclude_unset=True).items():
        setattr(inventory, key, value)

    db.commit()
    db.refresh(inventory)
    return inventory

# In crud.py - add proper stock management functions
def reserve_stock(db: Session, product_id: int, quantity: int) -> bool:
    """Reserve stock with proper transaction management"""
    try:
        inventory = get_inventory_by_product_id(db, product_id)
        if not inventory or inventory.quantity_available < quantity:
            return False
            
        inventory.quantity_available -= quantity
        inventory.quantity_reserve += quantity
        
        movement = models.StockMovement(
            product_id=product_id,
            change=-quantity,
            reason="reserved"
        )
        db.add(movement)
        db.commit()
        return True
    except Exception as e:
        db.rollback()
        raise e


# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\database.py ---
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
import os
from dotenv import load_dotenv
from logger import log

load_dotenv()

DB_URL = "mysql://root:QwBkKMTrBMzEfBUipJQgJowZKKLwtOlT@trolley.proxy.rlwy.net:16824/railway"

try:
    engine = create_engine(DB_URL)
    log.info("Database engine created successfully")
except Exception as e:
    log.error(f"Failed to create database engine: {e}")
    raise

SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    log.debug("Database session started")
    try:
        yield db
    finally:
        db.close()
        log.debug("Database session closed")



# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\data_generator.py ---
import random
from typing import List, Dict, Any
from faker import Faker
from sqlalchemy.orm import Session
from models import Product, Category, PriceHistory
from logger import log

class DataGenerator:
    def __init__(self):
        self.faker = Faker()
        self.global_categories = [
            "Fashion", "Electronics", "Home & Garden", "Food & Beverage",
            "Health & Beauty", "Books & Media", "Toys & Games",
            "Sports & Outdoors", "DIY & Hardware", "Furniture"
        ]
        self.category_subcategories = {
            "Fashion": ["Clothing", "Footwear", "Accessories"],
            "Electronics": ["Mobiles", "Laptops", "Appliances"],
            "Home & Garden": ["Decor", "Plants", "Kitchen"],
            "Food & Beverage": ["Snacks", "Drinks", "Groceries"],
            "Health & Beauty": ["Skincare", "Supplements", "Makeup"],
            "Books & Media": ["Books", "Magazines", "E-books"],
            "Toys & Games": ["Board Games", "Action Figures", "Educational"],
            "Sports & Outdoors": ["Fitness", "Cycling", "Camping"],
            "DIY & Hardware": ["Tools", "Paint", "Electrical"],
            "Furniture": ["Bedroom", "Office", "Living Room"]
        }
        self.brand_names = [
            "Astra", "Zenex", "Nova", "UrbanMode", "GearPro",
            "CraftHaus", "NextEra", "Skyline", "PureEssence", "Flytek"
        ]

    def create_categories(self, db: Session) -> List[Category]:
        log.info("Creating initial categories and subcategories...")
        categories = []
        try:
            for main_name in self.global_categories:
                main_cat = Category(name=main_name)
                db.add(main_cat)
                db.flush()
                categories.append(main_cat)

                sub_names = self.category_subcategories.get(main_name, [])
                for sub in sub_names:
                    sub_cat = Category(name=f"{main_name} - {sub}", parent_id=main_cat.id)
                    db.add(sub_cat)
                    db.flush()
                    categories.append(sub_cat)
            db.commit()
            log.info(f"Created {len(categories)} categories (including subcategories).")
        except Exception as e:
            db.rollback()
            log.error(f"Error while creating categories: {e}")
        return categories

    def generate_brand(self) -> str:
        return random.choice([
            random.choice(self.brand_names),
            f"{self.faker.last_name()} {random.choice(['Inc', 'Corp', 'Ltd', 'Group'])}",
            f"{self.faker.country_code()} Tech",
            f"{self.faker.word().capitalize()}Works"
        ])

    def generate_product_attributes(self, category_name: str) -> Dict[str, Any]:
        return {
            "color": self.faker.color_name(),
            "weight": (
                f"{random.uniform(0.2, 3.0):.2f} kg"
                if "Electronics" in category_name or "Toys" in category_name
                else f"{random.uniform(5.0, 50.0):.2f} kg"
                if "Furniture" in category_name
                else f"{random.uniform(0.5, 10.0):.2f} kg"
            ),
            "material": (
                random.choice(["Cotton", "Polyester", "Denim", "Wool", "Silk"])
                if "Fashion" in category_name
                else random.choice(["Wood", "Metal", "Glass", "Plastic", "Leather"])
                if "Furniture" in category_name
                else random.choice(["Plastic", "Aluminum", "Glass"])
            ),
            "rating": round(random.uniform(3.0, 5.0), 1)
        }

    def create_products(self, db: Session, categories: List[Category], count: int) -> List[Product]:
        log.info(f"Generating {count} product(s)...")
        products = []
        
        # Map categories that require expiry dates
        categories_with_expiry = {
            "Food & Beverage", "Health & Beauty"
        }
        
        try:
            for _ in range(count):
                if not categories:
                    raise ValueError("No categories available. Please create categories first.")
                category = random.choice(categories)

                stock_quantity = random.randint(0, 1000)

                # Inlined generate_product logic
                product_data = {
                    "name": f"{self.faker.word().capitalize()} {self.faker.word().capitalize()}",
                    "price": round(
                        random.uniform(200.0, 2000.0)
                        if "Electronics" in category.name or "Furniture" in category.name
                        else random.uniform(50.0, 500.0)
                        if "Fashion" in category.name
                        else random.uniform(10.0, 300.0),
                        2
                    ),
                    "category_id": category.id,
                    "brand": self.generate_brand(),
                    "attributes": self.generate_product_attributes(category.name)
                }

                product = Product(**product_data)
                db.add(product)
                db.flush()  # Ensure product.id is available for Inventory

                # ✅ Create complete Inventory for this product
                from models import Inventory
                from datetime import datetime, timedelta
                
                # Determine expiry date based on category
                if category.name in categories_with_expiry:
                    expiry_date = datetime.now() + timedelta(days=random.randint(30, 365))
                else:
                    expiry_date = datetime(9999, 12, 31)  # Sentinel for "no expiry"
                
                inventory = Inventory(
                    product_id=product.id,
                    quantity_available=stock_quantity,
                    quantity_reserve=random.randint(0, min(50, stock_quantity // 4)),  # Reserve some stock
                    reorder_level=random.randint(5, 25),  # Random reorder level
                    reorder_quantity=random.randint(20, 100),  # Random reorder quantity
                    unit_cost=round(product_data["price"] * random.uniform(0.4, 0.7), 2),  # Cost is 40-70% of selling price
                    last_restocked=datetime.now() - timedelta(days=random.randint(1, 30)),  # Recently restocked
                    expiry_date=expiry_date,
                    batch_number=self.faker.uuid4(),
                    location=self.faker.city()
                    # last_updated will be set automatically by the model's default
                )
                db.add(inventory)

                products.append(product)

            db.commit()
            log.info(f"Successfully created {len(products)} products with complete inventory records.")
        except Exception as e:
            db.rollback()
            log.error(f"Failed to create products: {e}")
        return products


    def randomly_update_prices(self, db: Session, products: List[Product], batch_size: int = 50, reason: str = "auto_scheduler") -> None:
        log.info("Starting batch price update...")
        try:
            selected = random.sample(products, min(batch_size, len(products)))
            for product in selected:
                old_price = product.price
                change_percent = random.uniform(-0.2, 0.2)
                new_price = round(old_price * (1 + change_percent), 2)
                new_price = max(new_price, 1.0)

                price_history = PriceHistory(
                    product_id=product.id,
                    old_price=old_price,
                    new_price=new_price,
                    reason=reason
                )

                product.price = new_price
                db.add(price_history)

            db.commit()
            log.info(f"Updated prices for {len(selected)} product(s).")
        except Exception as e:
            db.rollback()
            log.error(f"Batch price update failed: {e}")

    def randomly_update_stocks(self, db: Session, products: List[Product], batch_size: int = 50) -> None:
        log.info("Starting batch stock update with inventory management...")
        try:
            from models import Inventory
            from datetime import datetime
            
            selected = random.sample(products, min(batch_size, len(products)))
            restocked_count = 0
            updated_count = 0
            
            for product in selected:
                # Get the inventory record for this product
                inventory = db.query(Inventory).filter(Inventory.product_id == product.id).first()
                
                if not inventory:
                    log.warning(f"No inventory record found for product {product.id}")
                    continue
                
                # Simulate stock changes with realistic business scenarios
                scenario = random.choices(
                    ["normal_sales", "heavy_sales", "slow_sales", "restock"],
                    weights=[60, 25, 10, 5]  # 60% normal, 25% heavy sales, 10% slow, 5% restock
                )[0]
                
                if scenario == "heavy_sales":
                    change = random.randint(-100, -30)  # Big sales day
                elif scenario == "normal_sales":
                    change = random.randint(-30, -5)   # Regular sales
                elif scenario == "slow_sales":
                    change = random.randint(-10, 0)    # Slow day
                else:  # restock
                    change = random.randint(20, 100)   # Manual restock
                old_quantity = inventory.quantity_available
                new_quantity = max(0, inventory.quantity_available + change)
                
                # Update inventory and product
                inventory.quantity_available = new_quantity
                product.stock_quantity = new_quantity
                
                # Auto-restock if below reorder level (but not always - 20% chance)
                if new_quantity <= inventory.reorder_level and old_quantity > inventory.reorder_level:
                    if random.random() < 0.2:  # Only 20% chance of auto-restock (was 30%)
                        inventory.quantity_available += inventory.reorder_quantity
                        product.stock_quantity += inventory.reorder_quantity
                        inventory.last_restocked = datetime.now()
                        inventory.batch_number = self.faker.uuid4()
                        restocked_count += 1
                
                updated_count += 1

            db.commit()
            log.info(f"Updated stock for {updated_count} product(s). Auto-restocked {restocked_count} product(s).")
            
        except Exception as e:
            db.rollback()
            log.error(f"Batch stock update failed: {e}")

    def get_categories(self, db: Session) -> List[Category]:
        categories = db.query(Category).all()
        log.info(f"Retrieved {len(categories)} categories from database.")
        return categories




# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\extract.py ---
import os

# Change this to the directory you want to scan
ROOT_DIR = "C:\\Users\\user\\Documents\\GitHub\\Training\\Day-09,10,11,12\\Ecommerce_Products_API"

# Output file name
OUTPUT_FILE = "all_python_code.txt"

# Whether to include subdirectories
RECURSIVE = True

all_code = []

for root, dirs, files in os.walk(ROOT_DIR):
    for file in files:
        if file.endswith(".py"):
            file_path = os.path.join(root, file)
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    code = f.read()
                    all_code.append(f"# --- File: {file_path} ---\n{code}\n")
            except Exception as e:
                print(f"❌ Failed to read {file_path}: {e}")
    
    if not RECURSIVE:
        break  # Prevent going into subdirectories

# Write to a single .txt file
with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
    out.write("\n\n".join(all_code))

print(f"✅ All Python code has been written to: {OUTPUT_FILE}")



# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\logger.py ---
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log", mode='a', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

log = logging.getLogger(__name__)



# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\main.py ---
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI
from apscheduler.schedulers.background import BackgroundScheduler
from database import engine, Base, SessionLocal
from crud import get_all_products
from routers import product_router
from data_generator import DataGenerator
import os
from dotenv import load_dotenv
from logger import log
import models
import random

load_dotenv()

# Initialize scheduler and generator
scheduler = BackgroundScheduler()
generator = DataGenerator()

def scheduled_generate_product():
    db = SessionLocal()
    try:
        categories = generator.get_categories(db)
        if categories:
            count = random.randint(10, 100)
            log.info(f"Generating {count} new products...")
            generator.create_products(db, categories, count=count)
    except Exception as e:
        log.error(f"Error in scheduled_generate_product: {e}")
    finally:
        db.close()

def scheduled_price_update():
    db = SessionLocal()
    try:
        products = get_all_products(db)
        if products:
            log.info("Updating product prices...")
            generator.randomly_update_prices(db, products)
    except Exception as e:
        log.error(f"Error in scheduled_price_update: {e}")
    finally:
        db.close()

def scheduled_stock_update():
    db = SessionLocal()
    try:
        products = get_all_products(db)
        if products:
            log.info("Updating product stock quantities...")
            generator.randomly_update_stocks(db, products)
    except Exception as e:
        log.error(f"Error in scheduled_stock_update: {e}")
    finally:
        db.close()

print("Tables found:", Base.metadata.tables.keys())

ENABLE_SCHEDULER = os.getenv("ENABLE_SCHEDULER", "false").lower() == "true"

@asynccontextmanager
async def lifespan(app: FastAPI):
    log.info("Starting up...")
    
    try:
        Base.metadata.create_all(bind=engine)
        log.info("Database tables created or already exist.")
    except Exception as e:
        log.error(f"Error creating tables: {e}")

    db = SessionLocal()
    try:
        categories = generator.get_categories(db)
        if not categories:
            log.info("No categories found, creating initial categories...")
            generator.create_categories(db)
        else:
            log.info(f"Found {len(categories)} existing categories.")
    except Exception as e:
        log.error(f"Error initializing categories: {e}")
    finally:
        db.close()

    if ENABLE_SCHEDULER:
        log.info("Scheduler is enabled.")
        scheduler.add_job(scheduled_generate_product, "interval", seconds=30, id="generate_product")
        scheduler.add_job(scheduled_price_update, "interval", seconds=60, id="price_update")
        scheduler.add_job(scheduled_stock_update, "interval", seconds=90, id="stock_update")
        scheduler.start()
        log.info("Scheduler jobs started.")
    else:
        log.warning("Scheduler disabled — products will only generate manually")

    try:
        yield
    except asyncio.CancelledError:
        log.warning("Lifespan cancelled (probably due to shutdown)")
        raise
    finally:
        log.info("Shutting down...")
        if ENABLE_SCHEDULER and scheduler.running:
            scheduler.shutdown(wait=False)
            log.info("Scheduler shutdown complete.")



# Create FastAPI app
app = FastAPI(
    title="E-commerce Product API", 
    version="1.0",
    lifespan=lifespan
)

# Include routers
app.include_router(product_router.router)

@app.get("/")
def root():
    log.info("Root endpoint accessed.")
    return {"message": "Product API is running"}

@app.get("/health")
def health_check():
    log.info("Health check endpoint accessed.")
    return {
        "status": "healthy",
        "scheduler_running": scheduler.running,
        "jobs": [job.id for job in scheduler.get_jobs()]
    }



# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\models.py ---
from sqlalchemy import Column, Integer, String, Float, ForeignKey, JSON, DateTime, Numeric
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base
from datetime import datetime, timezone

# Utility function to get current UTC time
def utc_now():
    return datetime.now(timezone.utc)

class Category(Base):
    __tablename__ = "categories"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    parent_id = Column(Integer, ForeignKey('categories.id'), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    parent = relationship("Category", remote_side=[id], back_populates="children")
    children = relationship("Category", back_populates="parent", cascade="all, delete-orphan")
    products = relationship("Product", back_populates="category", cascade="all, delete-orphan")


class Product(Base):
    __tablename__ = "products"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False, index=True)
    price = Column(Numeric(10, 2), nullable=False, index=True)
    brand = Column(String(100), index=True)
    attributes = Column(JSON, nullable=True)
    category_id = Column(Integer, ForeignKey('categories.id'))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    category = relationship("Category", back_populates="products")
    price_history = relationship("PriceHistory", back_populates="product", cascade="all, delete-orphan")
    inventory = relationship("Inventory", back_populates="product", uselist=False, cascade="all, delete-orphan")
    stock_movements = relationship("StockMovement", back_populates="product", cascade="all, delete-orphan")


class PriceHistory(Base):
    __tablename__ = "product_history"

    id = Column(Integer, primary_key=True, index=True)
    product_id = Column(Integer, ForeignKey("products.id"), nullable=False)
    old_price = Column(Numeric(10, 2), nullable=False)
    new_price = Column(Numeric(10, 2), nullable=False)
    changed_at = Column(DateTime, default=utc_now)
    reason = Column(String(100), nullable=True)

    product = relationship("Product", back_populates="price_history")

class Inventory(Base):
    __tablename__ = "inventory"

    id = Column(Integer, primary_key=True, index=True)
    product_id = Column(Integer, ForeignKey("products.id"), nullable=False, unique=True)
    quantity_available = Column(Integer, default=0)
    quantity_reserve = Column(Integer, default=0)
    reorder_level = Column(Integer, default=10)
    reorder_quantity = Column(Integer, default=20)
    unit_cost = Column(Numeric(10, 2), nullable=True)
    last_restocked = Column(DateTime, nullable=True)
    expiry_date = Column(DateTime, nullable=True)
    batch_number = Column(String(100), nullable=True)
    location = Column(String(100), nullable=True)
    last_updated = Column(DateTime, default=utc_now, onupdate=utc_now)

    product = relationship("Product", back_populates="inventory")


class StockMovement(Base):
    __tablename__ = "stock_movements"

    id = Column(Integer, primary_key=True, index=True)
    # order_id = Column(Integer, nullable=True)  # Simple approach
    product_id = Column(Integer, ForeignKey("products.id"), nullable=False)
    change = Column(Integer, nullable=False)
    reason = Column(String(255), nullable=True)
    timestamp = Column(DateTime, default=utc_now)

    product = relationship("Product", back_populates="stock_movements")
    # order_id: Optional[int] = None



# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\schemas.py ---
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Dict, Any
from datetime import datetime

# =========================================================
# 🗂️ CATEGORY SCHEMAS
# =========================================================

class CategoryBase(BaseModel):
    name: str
    parent_id: Optional[int] = None

class Category(CategoryBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    children: List['Category'] = []

    class Config:
        from_attributes = True

# Update forward reference
Category.model_rebuild()

# =========================================================
# 💰 PRICE HISTORY SCHEMAS
# =========================================================

class ProductPriceHistoryBase(BaseModel):
    old_price: float
    new_price: float
    reason: Optional[str] = None

class ProductPriceHistory(ProductPriceHistoryBase):
    id: int
    product_id: int
    changed_at: datetime

    class Config:
        from_attributes = True

# =========================================================
# 📦 PRODUCT SCHEMAS
# =========================================================

# ---------- Input / Base Models ----------

class ProductBase(BaseModel):
    name: str
    price: float
    category_id: int
    brand: Optional[str] = None
    attributes: Optional[Dict[str, Any]] = None

class ProductCreate(ProductBase):
    pass

class ProductUpdate(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    price: Optional[float] = Field(None, gt=0, description="Price must be positive")
    category_id: Optional[int] = Field(None, gt=0, description="Category ID must be positive")
    brand: Optional[str] = Field(None, max_length=100)
    attributes: Optional[Dict[str, Any]] = None

    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        if v is not None and len(v.strip()) == 0:
            raise ValueError('Name cannot be empty or just whitespace')
        return v.strip() if v else v

    @field_validator('brand')
    @classmethod
    def validate_brand(cls, v):
        if v is not None and len(v.strip()) == 0:
            raise ValueError('Brand cannot be empty or just whitespace')
        return v.strip() if v else v

# ---------- Output / Full Models ----------

class ProductSummary(BaseModel):
    id: int
    name: str
    price: float
    brand: Optional[str] = None
    category_name: str
    rating: Optional[float] = None

    class Config:
        from_attributes = True

class Product(ProductBase):
    id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    category: Category
    price_history: List[ProductPriceHistory] = []

    class Config:
        from_attributes = True

# =========================================================
# 📋 PAGINATED RESPONSE SCHEMAS
# =========================================================

class ProductListResponse(BaseModel):
    total: int
    page: int
    per_page: int
    total_pages: int
    products: List[ProductSummary]

# =========================================================
# 🧮 INVENTORY SCHEMAS
# =========================================================

class InventoryBase(BaseModel):
    quantity_available: int = 0
    quantity_reserve: int = 0
    reorder_level: Optional[int] = 10
    reorder_quantity: Optional[int] = 20
    unit_cost: Optional[float] = None
    last_restocked: Optional[datetime] = None
    expiry_date: Optional[datetime] = None
    batch_number: Optional[str] = None
    location: Optional[str] = None

class Inventory(InventoryBase):
    id: int
    product_id: int
    last_updated: Optional[datetime] = None

    class Config:
        from_attributes = True

# In schemas.py
class InventoryUpdate(BaseModel):
    quantity_available: Optional[int] = Field(None, ge=0, description="Cannot be negative")
    reorder_level: Optional[int] = Field(None, ge=0)
    reorder_quantity: Optional[int] = Field(None, gt=0)
    
    @field_validator('reorder_quantity')
    @classmethod
    def validate_reorder_quantity(cls, v, info):
        if v is not None and info.data.get('reorder_level') is not None:
            if v <= info.data['reorder_level']:
                raise ValueError('Reorder quantity should be greater than reorder level')
        return v

# =========================================================
# 🔁 STOCK MOVEMENT SCHEMAS
# =========================================================

class StockMovementBase(BaseModel):
    product_id: int
    order_id: Optional[int] = None
    change: int
    reason: Optional[str] = None

class StockMovement(StockMovementBase):
    id: int
    timestamp: datetime

    class Config:
        from_attributes = True



# --- File: C:\Users\user\Documents\GitHub\Training\Day-09,10,11,12\Ecommerce_Products_API\routers\product_router.py ---
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import desc, func
from sqlalchemy.orm import Session
from typing import List, Optional, Union
import schemas, crud
from database import get_db
from data_generator import DataGenerator
from logger import log
import models

router = APIRouter(prefix="/products", tags=["Products"])
generator = DataGenerator()

@router.post("/", response_model=schemas.Product)
def create_product(product: schemas.ProductCreate, db: Session = Depends(get_db)):
    log.info(f"Creating product: {product.name}")
    return crud.create_product_manual(db, product)

@router.get("/", response_model=schemas.ProductListResponse)
def get_all_products(
    db: Session = Depends(get_db),
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(10, ge=1, le=100, description="Items per page"),
    search: Optional[str] = Query(None, description="Search products"),
    sort_by: str = Query("created_at", description="Sort by field"),
    sort_dir: str = Query("desc", regex="^(asc|desc)$", description="Sort direction"),
    min_price: Optional[float] = Query(None, ge=0, description="Minimum price"),
    max_price: Optional[float] = Query(None, ge=0, description="Maximum price"),
    category_id: Optional[int] = Query(None, description="Filter by category"),
    in_stock_only: bool = Query(False, description="Show only in-stock items")
):
    log.info(f"Fetching products | page={page}, per_page={per_page}, search='{search}', sort_by='{sort_by}', sort_dir='{sort_dir}'")
    
    skip = (page - 1) * per_page
    filters = {
        'min_price': min_price,
        'max_price': max_price,
        'category_id': category_id,
        'in_stock_only': in_stock_only
    }
    
    total, products = crud.get_paginated_products(
        db, skip, per_page, search, sort_by, sort_dir, filters
    )
    
    clean_products = []
    for product in products:
        rating = None
        if product.attributes and 'rating' in product.attributes:
            rating = product.attributes['rating']
        
        clean_products.append({
            "id": product.id,
            "name": product.name,
            "price": product.price,
            "brand": product.brand,
            "stock_quantity": product.inventory.quantity_available if product.inventory else 0,
            "category_name": product.category.name if product.category else "Unknown",
            "rating": rating
        })
    
    total_pages = (total + per_page - 1) // per_page
    log.info(f"Found {len(products)} products (Total: {total}, Total Pages: {total_pages})")
    
    return {
        "total": total,
        "page": page,
        "per_page": per_page,
        "total_pages": total_pages,
        "products": clean_products
    }

@router.get("/{product_id}", response_model=schemas.Product)
def get_product_by_id(product_id: int, db: Session = Depends(get_db)):
    log.info(f"Fetching product by ID: {product_id}")
    product = crud.get_product_by_id(db, product_id)
    if not product:
        log.warning(f"Product not found: ID {product_id}")
        raise HTTPException(status_code=404, detail="Product not found")
    return product

@router.post("/auto-generate", response_model=List[schemas.Product])
def auto_generate_products(count: int = 1, db: Session = Depends(get_db)):
    log.info(f"Auto-generating {count} products")
    categories = crud.get_all_categories(db)
    return generator.create_products(db, categories, count)

from fastapi import Query

@router.post("/update-prices")
def update_all_prices(
    count: int = Query(50, ge=1, le=500, description="Number of products to update"),
    db: Session = Depends(get_db)
):
    log.info(f"Updating prices for {count} product(s)")
    products = crud.get_all_products(db)
    if not products:
        log.warning("No products found to update prices")
        return {"message": "No products found to update"}
    generator.randomly_update_prices(db, products, batch_size=count)
    return {"message": f"Price updated for {min(count, len(products))} products"}


@router.patch("/{product_id}", response_model=schemas.Product)
def update_product(
    product_id: str,  # Accept string so name/brand are allowed
    product_update: schemas.ProductUpdate,
    db: Session = Depends(get_db)
):
    # Try resolving product by ID, name, or brand
    product = None
    if product_id.isdigit():
        product = crud.get_product_by_id(db, int(product_id))
    if not product:
        product = crud.get_product_by_name(db, product_id)
    if not product:
        product = crud.get_product_by_brand(db, product_id)
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")

    # Validate category exists if updating category
    if product_update.category_id is not None:
        valid_category_ids = [cat.id for cat in crud.get_all_categories(db)]
        if product_update.category_id not in valid_category_ids:
            raise HTTPException(status_code=400, detail="Invalid category_id")

    # Perform update
    updated_product = crud.update_product(db, product.id, product_update)  # use actual ID

    return updated_product

@router.get("/{product_id}/inventory", response_model=schemas.Inventory)
def get_product_inventory(product_id: int, db: Session = Depends(get_db)):
    inventory = crud.get_inventory_by_product_id(db, product_id)
    if not inventory:
        raise HTTPException(status_code=404, detail="Inventory not found")
    return inventory

@router.patch("/{product_id}/inventory")
def adjust_inventory(
    product_id: int,
    quantity_delta: int,
    reason: str = "manual adjustment",
    order_id: Optional[int] = None,
    db: Session = Depends(get_db)
):
    try:
        updated_inventory = crud.update_inventory_quantity(
            db, product_id, quantity_delta, reason, order_id
        )
        return {
            "message": f"Inventory updated for Product ID {product_id}",
            "new_quantity": updated_inventory.quantity_available
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/{product_id}/stock-movements", response_model=List[schemas.StockMovement])
def get_stock_movements(product_id: int, db: Session = Depends(get_db)):
    return crud.get_stock_movements_for_product(db, product_id)

@router.patch("/{product_id}/inventory/settings", response_model=schemas.Inventory)
def update_inventory_settings(
    product_id: int,
    inventory_update: schemas.InventoryUpdate,
    db: Session = Depends(get_db)
):
    try:
        updated_inventory = crud.update_inventory_settings(
            db=db,
            product_id=product_id,
            update_data=inventory_update
        )
        return updated_inventory
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/reserve", response_model=dict)
def reserve_products(
    reservations: Union[List[dict], dict],  # Single item or list: {"product_id": 1, "quantity": 2}
    order_id: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Reserve single or multiple products for an order (atomic operation)"""
    # Normalize input - convert single item to list
    if isinstance(reservations, dict):
        reservations = [reservations]
    
    try:
        reserved_items = []
        
        # First, validate all items can be reserved
        for item in reservations:
            inventory = crud.get_inventory_by_product_id(db, item["product_id"])
            if not inventory or inventory.quantity_available < item["quantity"]:
                db.rollback()
                raise HTTPException(
                    status_code=400, 
                    detail=f"Insufficient stock for product {item['product_id']} (requested: {item['quantity']}, available: {inventory.quantity_available if inventory else 0})"
                )
        
        # Then reserve all items
        for item in reservations:
            inventory = crud.get_inventory_by_product_id(db, item["product_id"])
            inventory.quantity_available -= item["quantity"]
            inventory.quantity_reserve += item["quantity"]
            
            # Add stock movement
            movement = models.StockMovement(
                product_id=item["product_id"],
                change=-item["quantity"],
                reason=f"reserve_order_{order_id}" if order_id else "reserve"
            )
            db.add(movement)
            reserved_items.append({
                **item,
                "remaining_available": inventory.quantity_available
            })
        
        db.commit()
        
        return {
            "success": True,
            "reserved_items": reserved_items,
            "total_items": len(reserved_items),
            "order_id": order_id,
            "message": f"Successfully reserved {len(reserved_items)} product(s)"
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/release", response_model=dict)
def release_products(
    reservations: Union[List[dict], dict],  # Single item or list: {"product_id": 1, "quantity": 2}
    order_id: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Release single or multiple reserved products (e.g., if user cancels checkout)"""
    # Normalize input - convert single item to list
    if isinstance(reservations, dict):
        reservations = [reservations]
    
    try:
        released_items = []
        
        for item in reservations:
            inventory = crud.get_inventory_by_product_id(db, item["product_id"])
            if inventory and inventory.quantity_reserve >= item["quantity"]:
                inventory.quantity_reserve -= item["quantity"]
                inventory.quantity_available += item["quantity"]
                
                # Add stock movement
                movement = models.StockMovement(
                    product_id=item["product_id"],
                    change=item["quantity"],
                    reason=f"release_order_{order_id}" if order_id else "release"
                )
                db.add(movement)
                released_items.append({
                    **item,
                    "new_available": inventory.quantity_available
                })
        
        db.commit()
        return {
            "success": True,
            "released_items": released_items,
            "total_items": len(released_items),
            "order_id": order_id,
            "message": f"Successfully released {len(released_items)} product(s)"
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/finalize", response_model=dict)
def finalize_products(
    reservations: Union[List[dict], dict],  # Single item or list: {"product_id": 1, "quantity": 2}
    order_id: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """Finalize single or multiple reserved products (convert reserves to sold)"""
    # Normalize input - convert single item to list
    if isinstance(reservations, dict):
        reservations = [reservations]
    
    try:
        finalized_items = []
        
        for item in reservations:
            inventory = crud.get_inventory_by_product_id(db, item["product_id"])
            if inventory and inventory.quantity_reserve >= item["quantity"]:
                inventory.quantity_reserve -= item["quantity"]
                # Don't add back to available - it's sold
                
                # Add stock movement
                movement = models.StockMovement(
                    product_id=item["product_id"],
                    change=-item["quantity"],
                    reason=f"finalize_order_{order_id}" if order_id else "finalize"
                )
                db.add(movement)
                finalized_items.append({
                    **item,
                    "remaining_reserved": inventory.quantity_reserve
                })
        
        db.commit()
        return {
            "success": True,
            "finalized_items": finalized_items,
            "total_items": len(finalized_items),
            "order_id": order_id,
            "message": f"Successfully finalized {len(finalized_items)} product(s)"
        }
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/featured", response_model=List[dict])
def get_featured_products(
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    """Get featured/popular products for homepage"""
    # Logic: products with high ratings or recent high sales
    products = db.query(models.Product)\
        .join(models.Inventory)\
        .filter(models.Inventory.quantity_available > 0)\
        .order_by(desc(models.Product.created_at))\
        .limit(limit).all()
    
    return [
        {
            "id": p.id,
            "name": p.name,
            "price": float(p.price),
            "brand": p.brand,
            "category_name": p.category.name if p.category else "Unknown",
            "rating": p.attributes.get("rating") if p.attributes else None,
            "stock_quantity": p.inventory.quantity_available if p.inventory else 0
        } for p in products
    ]

@router.get("/recommendations/{user_id}", response_model=List[dict])
def get_product_recommendations(
    user_id: int,
    limit: int = Query(5, ge=1, le=20),
    db: Session = Depends(get_db)
):
    """Get personalized product recommendations"""
    # Placeholder: In real implementation, this would use ML/user behavior
    # For now, return popular products from different categories
    products = db.query(models.Product)\
        .join(models.Inventory)\
        .filter(models.Inventory.quantity_available > 0)\
        .order_by(func.random())\
        .limit(limit).all()
    
    return [
        {
            "id": p.id,
            "name": p.name,
            "price": float(p.price),
            "brand": p.brand,
            "category_name": p.category.name if p.category else "Unknown",
            "rating": p.attributes.get("rating") if p.attributes else None,
            "stock_quantity": p.inventory.quantity_available if p.inventory else 0
        } for p in products
    ]
